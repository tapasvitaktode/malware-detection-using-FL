import numpy as np
import pandas as pd

import tkinter as tk
from tkinter import filedialog
import os
import random

import sklearn.model_selection as md
from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, f1_score, recall_score

import Preprocessor as pp


import warnings

########################################################################################################################
# Class for Federated Learning edge devices
########################################################################################################################


class EdgeDevice:
    federated_server = None

    def __init__(self, federated_server, test_data):
        self.benign_amount = None
        self.malware_amount = None
        self.federated_server = federated_server
        self.local_model = None
        self.local_data = None

        self.id = random.randint(1, 1780)
        self.metrics_per_iteration = []

        self.testing_set = test_data

        self.test_x = test_data.drop('type', axis=1)
        self.test_y = test_data['type']

        self.analyzed_files = []


########################################################################################################################
# INITIALIZATION METHODS
########################################################################################################################

    def init_data(self, dataset, malw_amount, ben_amount):
        """
        Method used to assign data during the original dataset partition process
        """

        self.local_data = dataset
        self.malware_amount = malw_amount
        self.benign_amount = ben_amount

    def device_menu(self):

        finish = False

        while not finish:
            print('')
            print('DEVICE #', self.id)
            print('================')
            print('(1) Local data stats')
            print('(2) Local model metrics')
            print('(3) Return to Federated Server Menu')

            option = input('Enter an option: ') or 5

            # Unexpected input handling
            if not pp.is_number(option):
                option = 5
            option = int(option)

            if option == 1:
                print('')
                print('Showing data statistics...')
                size = len(self.local_data)
                print('Local data total size:', size)
                malw_prop = len(self.local_data[self.local_data['type'] == 'Malicious'])
                ben_prop = len(self.local_data[self.local_data['type'] == 'Benign'])
                print('Malware samples:',malw_prop)
                print('Benign samples:', ben_prop)
                print('')
                print(self.local_data)
                print('')

            if option == 2:
                print('')
                print('Showing model metrics')
                for metric in self.metrics_per_iteration:
                    print('Iteration #', metric['iteration'])
                    print('Accuracy', metric['accuracy'])
                    print('Recall', metric['recall'])
                    print('Precision', metric['precision'])
                    print('')

            else:
                finish = True

    def initial_train(self):
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            train_x = self.local_data.drop('type', axis=1)
            train_y = self.local_data['type']
            self.local_model.fit(train_x, train_y)

    def train(self, iteration=1):

        train_x = self.local_data.drop('type', axis=1)
        train_y = self.local_data['type']

        self.local_model.fit(train_x, train_y)

        prediction = self.local_model.predict(self.test_x)

        # Metric collection
        metric_info = dict()
        metric_info['accuracy'] = accuracy_score(self.test_y, prediction)
        metric_info['recall'] = recall_score(self.test_y, prediction, pos_label='Malicious')
        metric_info['precision'] = precision_score(self.test_y, prediction, pos_label='Malicious')
        metric_info['iteration'] = iteration
        self.metrics_per_iteration.append(metric_info)

    def predict_testing_data(self):

        predictors = self.testing_set.drop('type', axis=1)
        target = self.testing_set['type']

        train_x, test_x, train_y, test_y = md.train_test_split(predictors, target, train_size=0.75, test_size=0.25,
                                                               random_state=42)

        prediction = self.local_model.predict(test_x)

        print(confusion_matrix(test_y, prediction))
        print('Accuracy', accuracy_score(test_y, prediction))

    def predict(self, dataframe):
        return self.local_model.predict(dataframe)



########################################################################################################################
# centralized approach.
########################################################################################################################

class NormalDevice:

    # Server to connect
    CentralizedServer = None

    malware_samples = benign_samples = None

########################################################################################################################
# INITIALIZATION METHODS
########################################################################################################################

    def __init__(self, server, identifier=0):
        self.id = identifier

        self.analyzed_files = []

        self.CentralizedServer = server

    def load_samples(self):
        self.malware_samples = self.CentralizedServer.malware_test
        self.benign_samples = self.CentralizedServer.benign_test

    def request(self, df):
        prediction = self.CentralizedServer.predict_new(df)

        return prediction


    def start_device_simulation(self):

        stop = False

        print('')
        print('YOU ARE NOW IN A SIMULATION OF A COMPUTER')
        print('=========================================')

        while stop is not True:

            print('')
            print('What do you want to do?')
            print('1. Test preselected malware files')
            print('2. Test preselected benign files')
            print('3. End simulation')
            print('')
            # Eval option
            option = (input('Enter option: ') or '10')
            

            # Unexpected input handling
            if not pp.is_number(option):
                option = '10'
            option = int(option)

            match option:

                case 1:
                    prediction, truth, confusion_matrix, accuracy_score = self.CentralizedServer.predict(self.malware_samples)
                    print('confusion matrix: ')
                    print(confusion_matrix)
                    print('accuracy: ',accuracy_score)
                case 2:
                    prediction, truth, confusion_matrix, accuracy_score = self.CentralizedServer.predict(self.benign_samples)
                    print('confusion matrix: ')
                    print(confusion_matrix)
                    print('accuracy: ',accuracy_score)
                case 3:
                    return






